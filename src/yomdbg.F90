MODULE YOMDBG

USE PARKIND1
USE IEEE_ARITHMETIC, ONLY : ISNAN => IEEE_IS_NAN

IMPLICIT NONE

LOGICAL :: LLDBG = .FALSE.
LOGICAL :: LLFALSE = .FALSE.

REAL (KIND=JPRB), POINTER :: ZZGMV (:,:,:,:) => NULL ()

INTEGER :: IBLOCK
!$OMP THREADPRIVATE (IBLOCK)

#ifdef UNDEF
INTERFACE PNNN
  MODULE PROCEDURE :: PNNN1, PNNN2
END INTERFACE
#endif

INTERFACE PCRC
  MODULE PROCEDURE :: PCRC1, PCRC2, PCRC3, PCRCI1, PCRCI3, PCRC4
END INTERFACE

INTERFACE PCRCPROM
  MODULE PROCEDURE :: PCRCPROM2, PCRCPROM3, PCRCPROM4, PCRCPROMI4
END INTERFACE 

INTEGER, PRIVATE :: NGPBLKS, NGPTOT

CONTAINS

SUBROUTINE PNAN (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN

IF (.NOT. LLDBG) RETURN

ILUN = 0

WRITE (ILUN, '(A,":",I6.6," ",A," ",I16)') CDF, KL, CDMESS, COUNT (ISNAN (P))
CALL FLUSH (ILUN)

END SUBROUTINE

SUBROUTINE PCRCPROM2 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: IBL, NPROMA, IE

REAL (KIND=JPRB) :: Z (NGPTOT)

Z = 0.

NPROMA = SIZE (P, 1)

DO IBL = 1, SIZE (P, 2)
  IE = MIN (IBL*NPROMA, NGPTOT) - (IBL-1)*NPROMA
  Z (1+(IBL-1)*NPROMA:MIN (IBL*NPROMA, NGPTOT)) = P (1:IE,IBL)
ENDDO

CALL PCRC (CDF, KL, Z, CDMESS)


END SUBROUTINE

SUBROUTINE PCRCPROM3 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: IBL, NPROMA, IE

REAL (KIND=JPRB) :: Z (NGPTOT, SIZE (P, 2))

Z = 0.

NPROMA = SIZE (P, 1)

DO IBL = 1, SIZE (P, 3)
  IE = MIN (IBL*NPROMA, NGPTOT) - (IBL-1)*NPROMA
  Z (1+(IBL-1)*NPROMA:MIN (IBL*NPROMA, NGPTOT),:) = P (1:IE,:,IBL)
ENDDO

CALL PCRC (CDF, KL, Z, CDMESS)

END SUBROUTINE

SUBROUTINE PCRCPROMI4 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: IBL, NPROMA, IE

INTEGER (KIND=JPIM) :: Z (NGPTOT, SIZE (P, 2), SIZE (P, 3))

Z = 0.

NPROMA = SIZE (P, 1)

DO IBL = 1, SIZE (P, 4)
  IE = MIN (IBL*NPROMA, NGPTOT) - (IBL-1)*NPROMA
  Z (1+(IBL-1)*NPROMA:MIN (IBL*NPROMA, NGPTOT),:,:) = P (1:IE,:,:,IBL)
ENDDO

CALL PCRC (CDF, KL, Z, CDMESS)

END SUBROUTINE

SUBROUTINE PCRCPROM4 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: IBL, NPROMA, IE

REAL (KIND=JPRB) :: Z (NGPTOT, SIZE (P, 2), SIZE (P, 3))

Z = 0.

NPROMA = SIZE (P, 1)

DO IBL = 1, SIZE (P, 4)
  IE = MIN (IBL*NPROMA, NGPTOT) - (IBL-1)*NPROMA
  Z (1+(IBL-1)*NPROMA:MIN (IBL*NPROMA, NGPTOT),:,:) = P (1:IE,:,:,IBL)
ENDDO

CALL PCRC (CDF, KL, Z, CDMESS)

END SUBROUTINE

SUBROUTINE PCRC1 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

SUBROUTINE PCRC2 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

SUBROUTINE PCRC3 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

SUBROUTINE PCRC4 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

SUBROUTINE PCRCI1 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
INTEGER (KIND=JPIM), INTENT (IN) :: P (:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

SUBROUTINE PCRCI3 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
INTEGER (KIND=JPIM), INTENT (IN) :: P (:,:,:)
CHARACTER (LEN=*) :: CDMESS

INTEGER :: ILUN
INTEGER*8 :: ICRC8, ILEN8

ILUN = 20

ICRC8 = 0
ILEN8 = SIZE (P) * KIND (P)

CALL CRC64 (P, ILEN8, ICRC8)

WRITE (ILUN, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (ILUN)

WRITE (0, '(A,":",I6.6," ",A," ",Z16.16)') CDF, KL, CDMESS, ICRC8
CALL FLUSH (0)

END SUBROUTINE

#ifdef UNDEF

SUBROUTINE PNNN1 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:)
CHARACTER (LEN=*) :: CDMESS
INTEGER :: J

IF (.NOT. LLDBG) RETURN

WRITE (ILUN, '(I6.6," ",I6.6," ",A,":",I6.6," ",A," NORM = ")', ADVANCE="NO") IBLOCK, ICOUNT_DBG, CDF, KL, CDMESS
WRITE (ILUN, '(E30.17," ",Z16.16)', ADVANCE='NO') SUM (ABS (P)), LOC (P (1))
WRITE (ILUN, *)

CALL FLUSH (ILUN)

ICOUNT_DBG = ICOUNT_DBG + 1

END SUBROUTINE

SUBROUTINE PNNN2 (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:,:)
CHARACTER (LEN=*) :: CDMESS
INTEGER :: J

IF (.NOT. LLDBG) RETURN

WRITE (ILUN, '(I6.6," ",I6.6," ",A,":",I6.6," ",A," NORM = ")', ADVANCE="NO") IBLOCK, ICOUNT_DBG, CDF, KL, CDMESS
WRITE (ILUN, '(E30.17," ",Z16.16)', ADVANCE='NO') SUM (ABS (P)), LOC (P (1, 1))
WRITE (ILUN, *)

CALL FLUSH (ILUN)

ICOUNT_DBG = ICOUNT_DBG + 1

END SUBROUTINE

SUBROUTINE PVVV (CDF, KL, P, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
REAL (KIND=JPRB), INTENT (IN) :: P (:)
CHARACTER (LEN=*) :: CDMESS
INTEGER :: J

IF (.NOT. LLDBG) RETURN

WRITE (ILUN, '(I6.6," ",I6.6," ",A,":",I6.6," ",A," ")', ADVANCE="NO") IBLOCK, ICOUNT_DBG, CDF, KL, CDMESS
DO J = 1, SIZE (P)
  WRITE (ILUN, '(E30.17," ")', ADVANCE='NO') P (J)
ENDDO
WRITE (ILUN, *)

CALL FLUSH (ILUN)

ICOUNT_DBG = ICOUNT_DBG + 1

END SUBROUTINE

SUBROUTINE PIIII (CDF, KL, K, CDMESS)

CHARACTER (LEN=*) :: CDF
INTEGER :: KL
INTEGER :: K
CHARACTER (LEN=*) :: CDMESS

IF (.NOT. LLDBG) RETURN

WRITE (ILUN, '(I6.6," ",I6.6," ",A,":",I6.6," ",A," ")', ADVANCE="NO") IBLOCK, ICOUNT_DBG, CDF, KL, CDMESS
WRITE (ILUN, '(I0)', ADVANCE='NO') K
WRITE (ILUN, *)

CALL FLUSH (ILUN)

ICOUNT_DBG = ICOUNT_DBG + 1

END SUBROUTINE

#endif

END MODULE
